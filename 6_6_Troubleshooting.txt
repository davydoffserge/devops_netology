Домашнее задание к занятию "6.6. Troubleshooting "

1.Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.
Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.
Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.

Ответ:
В оболочке MongoDB необходимо выполнить команду: db.currentOp (), которая сообщает о текущих текущих операциях для экземпляра базы данных MongoDB.

Команда: db.killOp (<opid>) - Завершает операцию, указанную идентификатором операции (возвращается функцией db.currentOp () ). 
Рекомендация для этой команды — использовать ее для завершения операций, инициированных только клиентами, и не завершать операции внутренней базы данных.
Для решения проблемы с зависающими запросами, возможно будет необходимо  добавить новый индекс, используя мотод выявления .explain("executionStats")

https://medium.com/mongodb-cowboys/troubleshooting-mongodb-100-cpu-load-and-slow-queries-da622c6e1339


2.Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.
Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.
При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи
Как вы думаете, в чем может быть проблема?

Ответ:
Отслеживание пропускной способности обработанных команд имеет решающее значение для диагностики причин высокой задержки в вашем экземпляре Redis. 
Высокая задержка может быть вызвана рядом проблем, от невыполненной очереди команд до медленных команд и чрезмерного использования сетевых каналов. 
Мы можем провести исследование, измерив количество команд, обрабатываемых в секунду — если оно остается почти постоянным, причина не в том, что команда требует больших вычислительных ресурсов.
Если одна или несколько медленных команд вызывают проблемы с задержкой, мы увидим, что количество команд в секунду упадет или полностью остановится.

При использовании Redis в качестве кеша мониторинг частоты попаданий в кеш может сказать, эффективно ли используется кеш. 
Низкий уровень совпадений означает, что клиенты ищут ключи, которых больше не существует. 

hit rate = keyspace_hits / (keyspace_hits + keyspace_misses)

Низкая частота попаданий в кэш может быть вызвана рядом факторов, в том числе истечением срока действия данных и недостаточным объемом памяти, выделенной для Redis 
(что может привести к вытеснению ключа). Низкая частота обращений может привести к увеличению задержки приложений, поскольку им приходится извлекать данные 
из более медленного ресурса.

#Поскольку Redis последовательно обрабатывает каждую операцию, что означает, что удаление большого количества ключей может снизить частоту обращений, увеличивая тем самым задержку.
#При использовании TTL, мы можем не ожидать сброса значения ключа. В этом случае, если этот показатель всегда выше нуля, можно увидеть увеличение задержки в экземпляре.
#Большинство других конфигураций, которые не используют TTL, в конечном итоге исчерпают память и начнут очищать значение ключа. Пока наше время ответа приемлемо, 
#мы можем принять стабильный уровень разрешения. Когда будет достигнут предел памяти и пользователь попытается добавить еще один ключ, будет возвращена ошибка.
#( Другими словами, запись не допускается после достижения предела памяти).

Соответственно проблема в исчерпании ресурсов оперативной памяти.

https://russianblogs.com/article/7125451930/



3. Перед выполнением задания познакомьтесь с документацией по Common Mysql errors.
Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
       InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '

Как вы думаете, почему это начало происходить и как локализовать проблему?
Какие пути решения данной проблемы вы можете предложить?

Ответ:
Обычно это указывает на проблемы с сетевым подключением, и мы должны проверить состояние нашей сети, если эта ошибка возникает часто. 
Иногда форма «во время запроса» возникает, когда миллионы строк отправляются как часть одного или нескольких запросов. 
Если вы знаете, что это происходит, вы должны попытаться увеличить net_read_timeout с 30 секунд по умолчанию до 60 секунд или больше, что достаточно для завершения передачи данных.
Реже это может произойти, когда клиент пытается установить начальное соединение с сервером. В этом случае, если значение connect_timeout установлено всего в несколько секунд, 
Можно решить проблему, увеличив ее до десяти секунд, возможно, больше, если у имеем очень большое расстояние или медленное соединение. 
Если причина не в одной из только что описанных, возможно, возникла проблема со значениями больших двоичных объектов, превышающими max_allowed_packet,
 что может привести к этой ошибке у некоторых клиентов. Иногда вы можете увидеть ошибку ER_NET_PACKET_TOO_LARGE, и это подтверждает, что вам нужно увеличить max_allowed_packet.

https://dev.mysql.com/doc

4.Перед выполнением задания ознакомтесь со статьей Common PostgreSQL errors из блога Percona.
Вы решили перевезти гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.
После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
postmaster invoked oom-killer

Как вы думаете, что происходит?
Как бы вы решили данную проблему?

Ответ:
 Когда это происходит, можно получить примерно такое сообщение ядра :
Out of Memory: Killed process 12345 (postgres).
Это сообщение говорит о том, что процесс postgres был уничтожен из-за нехватки памяти. Хотя существующие подключения к базе данных будут работать по-прежнему, 
новые подключения приниматься не будут. Чтобы восстановить работу сервера, Postgres Pro придётся перезапустить. Один из способов обойти эту проблему — запускать Postgres Pro на компьютере, 
где никакие другие процессы не займут всю память. Если физической памяти недостаточно, решить проблему также можно, увеличив объём пространства подкачки, 
так как уничтожение процессов при нехватке памяти происходит только когда заканчивается и физическая память, и место в пространстве подкачки. 
Эту проблему можно решить, увеличив размер ОЗУ, а также изменив конфигурацию сервера. В некоторых случаях может помочь уменьшение конфигурационных параметров, связанных с памятью, а именно shared_buffers и work_mem.

https://postgrespro.ru/docs/postgrespro


