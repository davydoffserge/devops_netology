#1)Какой системный вызов делает команда cd? cd не является самостоятельной программой, это shell builtin, 
#поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'.
#В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте. 
#нужно найти тот единственный, который относится именно к cd. 
#Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.

#execve("/bin/bash", ["/bin/bash", "-c", "cd /tmp"], 0x7ffe9a169a20 /* 24 vars */) = 0

#2)Попробуйте использовать команду file на объекты разных типов на файловой системе. 
#Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.

#openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3

#3)Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), 
#однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет.
#Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается.
#Основываясь на знаниях о перенаправлении потоков предложите способ обнуления 
#открытого удаленного файла (чтобы освободить место на файловой системе).

#в новой сессии терминала запускаем пинг ping 127.0.0.1 > /tmp/pinglocalhost.txt
#lsof -u serge ищем по имени пользователя процесс ping, получаем результет PID = 3721

#sudo lsof -p 3721 ищем файловый дескриптор процесса FD = 1w
#rm /tmp/pinglocalhost.txt - удаляем лог-файл
#cat /tmp/pinglocalhost.txt - получаем ошибку...
#sudo cat  /proc/3721/fd/1 > /home/serge/pinglocalhost.txt   - перенаправляем по PID  и FD  в свободное место файловой системы.

#4)Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
#Зомби процессы Linux не выполняются и убить их нельзя, даже с помощью sigkill, 
#Зомби" процессы, освобождают свои ресурсы, но не освобождают запись в таблице процессов.
#Посмотреть такие процессы можно с помощью утилиты ps, здесь они отмечаются как defunct:

#ps aux | grep defunct

#5) В iovisor BCC есть утилита opensnoop:
# root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
# /usr/sbin/opensnoop-bpfcc
# На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04.

# /usr/sbin/opensnoop-bpfcc
#opensnoop  представляет собой механизм ядра,  показывая, какие процессы пытаются открыть какие файлы. 
#Это работает путем отслеживания функции ядра с помощью динамической трассировки, чтобы соответствовать любым изменениям
# в этой функции, для определения местоположения файлов конфигурации, и журналов или для устранения неполадок приложений, которые выходят из строя, особенно при запуске.

#6) Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, 
#где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.

#это утилита командной строки, которая выводит основную информацию об имени операционной системы и аппаратном обеспечении системы.
#  Part of the utsname information is also accessible via proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}
#Имя ядра, имя хоста, версия ядра, аппаратную платформу и т.д., посмотреть можно через стандартный редактор nano.

#7)Чем отличается последовательность команд через ; и через && в bash? Например:
#root@netology1:~# test -d /tmp/some_dir; echo Hi
#Hi
#root@netology1:~# test -d /tmp/some_dir && echo Hi
#root@netology1:~#

#Есть ли смысл использовать в bash &&, если применить set -e?

#синтакис ";" -перечисление по порядку, (разделитель). "&&" - сокращенное логическое "И", выполнить сначала команду 1, а затем команду 2, при удачном выполнении команды 1.
# при неудачном выполнении команды 1, выполняться команда 2 вообще не будет.
# "set -e" - прекращает выполнение скрипта, если команда завершилась ошибкой, выводит в stderr строку с ошибкой.
#команды различных типов, и перечисления, логическая и проверки на ошибку и не стоит их сравнивать между собой.

#8) Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?

# "set -e" - прекращает выполнение скрипта, если команда завершилась ошибкой, выводит в stderr строку с ошибкой.
#По-умолчанию, игнорируются любые неудачи и сценарий продолжет выполнятся. 
#Если предполагается, что команда может завершиться с ошибкой, но это не критично, можно использовать пайплайн || true.
#Но "set -e" не идеален. Bash возвращает только код ошибки последней команды в пайпе (конвейере). И параметр "-e" проверяет только его. 
#Если нужно убедиться, что все команды в пайпах завершились успешно, нужно использовать "-o pipefail."
#Наверно самый полезный параметр - "-u". Благодаря ему оболочка проверяет инициализацию переменных в скрипте.
#Если переменной не будет, скрипт немедленно завершиться. Данный параметр достаточно умен, чтобы нормально работать 
#с переменной по-умолчанию ${MY_VAR:-$DEFAULT} и условными операторами (if, while, и др).
#Параметр "-x" очень полезен при отладке. С помощью него bash печатает в стандартный вывод все команды перед их исполнением. 
#Стоит учитывать, что все переменные будут уже доставлены, и с этим нужно быть аккуратнее, к примеру если используете пароли.
#Эти параметры можно объединять и комбинировать между собой. Оболочка bash обычно смотрит только на код выхода последней команды конвейера. 
#Такое поведение не является идеальным, поскольку оно приводит к тому, что "-e" опция может действовать только на код выхода последней команды конвейера. 
#Вот здесь-то и начинается "set -euxo pipefail".

#9)Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES),
# что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными)

#наиболее часто встречающиеся процессы S(S, Ss, Ss+, SsL, SLsl, S<s, SN) - состояние прерывистого сна, I(I, I<) - фоновые процессы, R - процесс выполняется в данный момент. 

