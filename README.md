#devops-netology

#1)#execve("/bin/bash", ["/bin/bash", "-c", "cd /tmp"], 0x7ffe9a169a20 /* 24 vars */) = 0

#2)openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3

#3)в новой сессии терминала запускаем пинг ping 127.0.0.1 > /tmp/pinglocalhost.txt

#lsof -u serge ищем по имени пользователя процесс ping, получаем результет PID = 3721

#sudo lsof -p 3721 ищем файловый дескриптор процесса FD = 1w

#rm /tmp/pinglocalhost.txt - удаляем лог-файл

#cat /tmp/pinglocalhost.txt - получаем ошибку...

#sudo cat  /proc/3721/fd/1 > /home/serge/pinglocalhost.txt   - перенаправляем по PID  

#и FD  в свободное место файловой системы.

#4)"Зомби" процессы, освобождают свои ресурсы, но не освобождают запись в таблице процессов.

#Посмотреть такие процессы можно с помощью утилиты ps, здесь они отмечаются как defunct:

#ps aux | grep defunct

#5)/usr/sbin/opensnoop-bpfcc

#opensnoop  представляет собой механизм ядра,  показывая, какие процессы пытаются открыть какие файлы.

#Это работает путем отслеживания функции ядра с помощью динамической трассировки, чтобы соответствовать

#любым измкнениям в этой функции, для определения местоположения файлов конфигурации, и журналов 

#или для устранения неполадок приложений, которые выходят из строя, особенно при запуске.

#6)это утилита командной строки, которая выводит основную информацию об имени операционной системы 

#и аппаратном обеспечении системы.

#Part of the utsname information is also accessible via proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}

#Имя ядра, имя хоста, версия ядра, аппаратную платформу и т.д., посмотреть можно через стандартный редактор nano.

#7)синтакис ";" -перечисление по порядку, (разделитель). "&&" - сокращенное логическое "И", 

#выполнить сначала команду 1, а затем команду 2, при удачном выполнении команды 1.

#при неудачном выполнении команды 1, выполняться команда 2 вообще не будет.

#"set -e" - прекращает выполнение скрипта, если команда завершилась ошибкой, выводит в stderr строку с ошибкой.

#команды различных типов, и перечисления, логическая и проверки на ошибку и не стоит их сравнивать между собой.

#8)"set -e" не идеален, прекращает выполнение скрипта, если команда завершилась ошибкой, выводит в stderr строку с ошибкой.

#Если предполагается, что команда может завершиться с ошибкой, но это не критично, можно использовать пайплайн || true

#Bash возвращает только код ошибки последней команды в пайпе (конвейере). И параметр "-e" проверяет только его.

#Если нужно убедиться, что все команды в пайпах завершились успешно, нужно использовать "-o pipefail."

#благодаря параметру "-u" оболочка проверяет инициализацию переменных в скрипте.

#если переменной не будет, скрипт немедленно завершиться.

#параметр "-x" очень полезен при отладке. С помощью него bash печатает в стандартный вывод все команды перед их исполнением.

#пареметры можно комбинировать между собой. "-e" действует только на выход, "set -euxo pipefail" - от верха до низа.

#9)наиболее часто встречающиеся процессы S(S, Ss, Ss+, SsL, SLsl, S<s, SN) - состояние прерывистого сна,

#I(I, I<) - фоновые процессы, R - процесс выполняется в данный момент.




