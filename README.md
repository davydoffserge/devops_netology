#devops-netology

#1)cd встроенная команда, позволяет изменять каталоги.

#2)#openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3

#3)#в новой сессии терминала запускаем пинг ping 127.0.0.1 > /tmp/pinglocalhost.txt

#lsof -u serge ищем по имени пользователя процесс ping, получаем результет PID = 3721

#sudo lsof -p 3721 ищем файловый дескриптор процесса FD = 1w

#rm /tmp/pinglocalhost.txt - удаляем лог-файл

#cat /tmp/pinglocalhost.txt - получаем ошибку...

#sudo cat  /proc/3721/fd/1 > /home/serge/pinglocalhost.txt   - перенаправляем по PID  

#и FD в свободное место файловой системы.

#4)Зомби процессы Linux не выполняются и убить их нельзя, даже с помощью sigkill, 

#Зомби" процессы, освобождают свои ресурсы, но не освобождают запись в таблице процессов.

#Посмотреть такие процессы можно с помощью утилиты ps, здесь они отмечаются как defunct:

#ps aux | grep defunct

#5)# /usr/sbin/opensnoop-bpfcc

#opensnoop  представляет собой механизм ядра,  показывая, какие процессы пытаются открыть какие файлы. 

#Это работает путем отслеживания функции ядра с помощью динамической трассировки, чтобы соответствовать любым изменениям

# в этой функции, для определения местоположения файлов конфигурации, и журналов или для устранения неполадок приложений,

#которые выходят из строя, особенно при запуске.

#6)#это утилита командной строки, которая выводит основную информацию об имени операционной системы и 

#аппаратном обеспечении системы.

#Part of the utsname information is also accessible via proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}

#Имя ядра, имя хоста, версия ядра, аппаратную платформу и т.д., посмотреть можно через стандартный редактор nano.

#7)#синтакис ";" -перечисление по порядку, (разделитель). "&&" - сокращенное логическое "И", выполнить сначала команду 1,

# а затем команду 2, при удачном выполнении команды 1.

# при неудачном выполнении команды 1, выполняться команда 2 вообще не будет.

#"set -e" - прекращает выполнение скрипта, если команда завершилась ошибкой, выводит в stderr строку с ошибкой.

#команды различных типов, и перечисления, логическая и проверки на ошибку и не стоит их сравнивать между собой.

#8)команды различных типов, и перечисления, логическая и проверки на ошибку и не стоит их сравнивать между собой.

#По-умолчанию, игнорируются любые неудачи и сценарий продолжет выполнятся. 

#Если предполагается, что команда может завершиться с ошибкой, но это не критично, можно использовать пайплайн || true.

#Но "set -e" не идеален. Bash возвращает только код ошибки последней команды в пайпе (конвейере). И параметр "-e" проверяет только его.

#Если нужно убедиться, что все команды в пайпах завершились успешно, нужно использовать "-o pipefail."

#Наверно самый полезный параметр - "-u". Благодаря ему оболочка проверяет инициализацию переменных в скрипте.

#Если переменной не будет, скрипт немедленно завершиться. Данный параметр достаточно умен, чтобы нормально работать 

#с переменной по-умолчанию ${MY_VAR:-$DEFAULT} и условными операторами (if, while, и др).

#Параметр "-x" очень полезен при отладке. С помощью него bash печатает в стандартный вывод все команды перед их исполнением. 

#Стоит учитывать, что все переменные будут уже доставлены, и с этим нужно быть аккуратнее, к примеру если используете пароли.

#Эти параметры можно объединять и комбинировать между собой. Оболочка bash обычно смотрит только на код выхода последней команды конвейера. 

#Такое поведение не является идеальным, поскольку оно приводит к тому, что "-e" опция может действовать только на код выхода последней команды конвейера. 

#Вот здесь-то и начинается "set -euxo pipefail".

#9)наиболее часто встречающиеся процессы S(S, Ss, Ss+, SsL, SLsl, S<s, SN) - состояние прерывистого сна, I(I, I<) - фоновые процессы, R - процесс выполняется в данный момент.
